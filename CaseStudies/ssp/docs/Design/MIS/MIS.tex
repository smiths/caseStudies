\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
	bookmarks=true,     % show bookmarks bar?
	colorlinks=true,       % false: boxed links; true: colored links
	linkcolor=red,          % color of internal links (change box color with 
	%linkbordercolor)
	citecolor=blue,      % color of links to bibliography
	filecolor=magenta,  % color of file links
	urlcolor=cyan          % color of external links
}

\usepackage{array}

\newcounter{tablenum} %Table number
\newcommand{\tablethetablenum}{Table\thetablenum}
\newcommand{\tableref}[1]{Table\ref{#1}}
\newcounter{modulenum} %Module number
\newcommand{\modulethemodulenum}{Module\themodulenum}
\newcommand{\moduleref}[1]{Module\ref{#1}}
\newcounter{algnum} %Algorithm number
\newcommand{\algthealgnum}{NA\thealgnum}
\newcommand{\algref}[1]{NA\ref{#1}}

%\newcommand{\forceindent}{\parindent=1em\indent\parindent=0pt\relax}

%\oddsidemargin -1000mm
%\evensidemargin -1000mm
%\textwidth 160mm
%\textheight 300mm
%\newgeometry{margin=2cm}

\externaldocument[MG-]{../MG/MG}
\externaldocument[SRS-]{../../SRS/SRS}

\newcommand{\iref}[1]{IM\ref{#1}}
\newcommand{\dref}[1]{GD\ref{#1}}

\input{../../Comments}

\newcommand{\progname}{SSP}

\begin{document}

\title{Module Interface Specification for Slope Stability Analysis Program 
(\progname)} 
\author{Henry Frankis and Brooks MacLachlan}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
	\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
	\midrule
	11/12/18 & 1.0 & Initial updates based on template\\
	11/21/18 & 1.1 & Finished updating all of the modules\\
	11/29/18 & 1.2 & Added additional constants to the genetic algorithm module 
	for the adding of vertices to slip surfaces\\
	\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See Section~\ref{SRS-sec_RefMat} of the Software Requirements Specification 
(SRS) document, available in
\href{https://github.com/smiths/caseStudies/blob/master/CaseStudies/ssp/docs/SRS/SRS.pdf}
{the GitHub repository for the project}.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname, a program for determining the critical slip surface and 
corresponding factor of safety for a given sloped mass of soil. The document is 
intended to ease understanding of the design of \progname{} and should be used 
as a resource for any maintenance of \progname{}.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at 
\href{https://github.com/smiths/caseStudies/tree/master/CaseStudies/ssp}
{the GitHub repository for the project}. \wss{good to point to repo}

% ---------------------------------------------------------------- %
% ------------------------ NOTATION ------------------------------ %
% ---------------------------------------------------------------- %

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol $\coloneqq$ is used 
for a multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | \dots | c_n \Rightarrow r_n )$. The 
notation for quantifiers is from \citet{GriesAndSchneider1993}.

The following table summarizes the primitive data types used by \progname.

~\newline \renewcommand*{\arraystretch}{1.5}
\begin{tabular}{p{0.2\textwidth} p{0.1\textwidth} p{0.7\textwidth}}
  \hline \textbf{Data Type} & \textbf{Notation} & \textbf{Description}
  \\ \hline
  
  character & char & a single symbol or digit\\

  boolean & $\mathbb{B}$ & a value from the set \{true, false\}\\
  
  real & $\mathbb{R}$ & any number in $\left( -\infty, \infty \right)$\\
  
  integer & $\mathbb{Z}$ & a number without a fractional component in $\left( 
  -\infty, \infty \right)$\\
  \bottomrule
\end{tabular}

~\newline
The specification of \progname{} uses some derived data types: sequences, 
strings, and tuples. Sequences are ordered lists of elements of the same data 
type, denoted by brackets enclosing the type of the data elements. If a 
sequence has fixed dimensions, the notation of the type will include the 
dimensions in superscript. Strings are sequences of characters. Tuples contain 
a list of values, potentially of different types, each associated with a field 
identifier. When a tuple is referenced in this document, a link to an appendix 
section that specifies the fields of the tuple will be provided. In addition, 
\progname \ uses functions, which are defined by the data types of their inputs 
and outputs. Local functions are described by giving their type signature 
followed by their specification.

% ---------------------------------------------------------------- %
% ------------------------ ALGORITHM ----------------------------- %
% ---------------------------------------------------------------- %

\section{Numerical Algorithms}

\subsection*{Morgenstern-Price (Section \ref{sec:MPMod})}
The non-linear nature of the systems of equations in the Morgenstern-Price 
solver algorithm requires that the equations for
the factor of safety (IM\ref{SRS-IM_FS}), the interslice normal-to-shear force 
ratio (IM\ref{SRS-IM_Lambda}), and the interslice normal forces 
(IM\ref{SRS-IM_E}) are solved iteratively, with an initial guess for two of the 
values, typically the factor of safety and interslice normal-to-shear force 
ratio.

\subsection*{Genetic Algorithm (Section \ref{sec:GenAlgMod})}
\progname{} uses a genetic algorithm to find the coordinates of the
critical slip surface vertices that minimize the factor of safety, as described 
in IM\ref{SRS-IM_Min}. The genetic algorithm generates a set of initial 
potential slip surfaces, and subsequent generations are created by merging and 
mutating slip surfaces with low factors of safety from the previous generation. 
The minimum factor of safety after several generations is assumed to correspond 
to the critical slip surface.

\bmac{This section is not on the template. I've left it in for now because the 
information does seem useful, but maybe this is not the right place for it? 
Maybe this should go to an appendix?}

\wss{I like this content too.  I particularly like that IM1 to IM4 are invoked.
  I think it is fine to keep this content here.  This information might belong
  to the ``connection between the requirement and design'' section of the MG,
  but that feels a bit premature.  Let's leave it here for now.}

% ---------------------------------------------------------------- %
% --------------------- MODULE DECOMPOSITION --------------------- %
% ---------------------------------------------------------------- %

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this 
project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth} }
		\toprule
		\textbf{Level 1} & \textbf{Level 2} \\
		\midrule
		
		{Hardware-Hiding} & ~ \\
		\midrule
		
		\multirow{8}{0.3\textwidth}{Behaviour-Hiding} &
		Control \\
		& Input \\
		& Genetic Algorithm \\
		& Kinematic Admissibility \\
		& Slip Weighting \\
		& Slip Slicing \\
		& Morgenstern-Price Calculation \\
		& Slice Property Calculation \\
		& Output \\
		\midrule
		
		\multirow{3}{0.3\textwidth}{Software Decision} &
		Sequence Data Structure \\
		& Random Number Generation \\
		& Plotting \\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{Table:Decomp}
\end{table}

% ---------------------------------------------------------------- %
% --------------------- CONTROL MODULE --------------------------- %
% ---------------------------------------------------------------- %

\clearpage
\newpage
\section{MIS of the Control Module}

\subsection{Module}
Control

\subsection{Uses}

Input (Section \ref{sec:InputMod}), Output (Section \ref{sec:OutputMod}), 
GenAlg (Section \ref{sec:GenAlgMod}), Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand*{\arraystretch}{1.5}
\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
p{0.45\textwidth} } \hline 
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline

  Control & string & - & - \\ \hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

The access program is called with a string parameter.

\subsubsection{Access Routine Semantics}

control(\textit{fname}):
\begin{itemize}
	\item transition: 
	\begin{itemize}
		\item[] Modifies the state of the Input Module by calling it, calls the 
		Genetic Algorithm Module, and calls the Output Module. The series of 
		calls is shown in more detail below.
	\end{itemize}
\end{itemize}

load\_params(\textit{fname});\\

verify\_params();\\

[\textit{Fs}, \textit{crit\_slip}, \textit{G}, \textit{X}] = genetic\_alg();\\

verify\_output(\textit{Fs});\\

output(\textit{Fs}, \textit{crit\_slip}, \textit{G}, \textit{X}, 
\textit{fname})\\

\wss{This function doesn't give me enough information.  What is fname?  Is it a
  file name?  What states are being transitioned?  The state of the Input
  Module?  Can you explain the control module by giving the series of calls to
  the other access programs?  Something along the lines of what is done for 
  SWHS?}

\bmac{Added the series of calls and modified the text since it was giving the 
false impression of changing the state of more than just the Input Module. Is 
this better?}

\subsubsection{Local Functions}

N/A

% ---------------------------------------------------------------- %
% ---------------------- INPUT MODULE ---------------------------- %
% ---------------------------------------------------------------- %

\newpage \wss{Add a new page between all modules}
\bmac{Done}
\section{MIS of the Input Module} \label{sec:InputMod}

\subsection{Module}
Input

\subsection{Uses}
Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{p{0.14\textwidth} c p{0.8\textwidth}}
	coord &=& tuple of (x : $\mathbb{R}$, y : $\mathbb{R}$) \\
	coords &=& [coord] \\
\end{longtable}

\wss{The above types don't really have anything specifically to do with the
  input module.  I suggest that you add a new module ``Types'' that exports your
  ``global'' types for this program.  This is the same idea as a module for exporting
  constants that are used throughout a specification.}

\wss{I like that the appendix explains these types.  The names are very
  esoteric.  An explanation is helpful.}

\wss{I've been looking in the document for where these types are used and, at
  least for the ones that I've checked, they don't seem to be used anywhere
  other than here.  If that is the case, why even export types like this?  They
  could just be defined locally, or not defined at all.  The main thing seems to
  be having a way to capture the input parameters and the access programs that
  provide output seem to do that fine.}

\bmac{The motivation behind these types was to clean up the specifications. 
When I first wrote these, I had the tuples being passed around to all of the 
functions instead of being state variables, and so the specifications got 
really cluttered with these long tuples. Since I switched to state variables, 
maybe I could have removed these types, because you're right that the types 
aren't used in the rest of the document.}

\bmac{I have now removed the types which were not used anywhere else}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand*{\arraystretch}{1.5}
\begin{tabular}{p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth}  
p{0.45\textwidth} } \hline 

  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline

   load\_params & string & - & 
   fileNotExist, badFileExtension, unexpectedInput  \\
   
   verify\_params & - & - & 
   badSlopeGeometry, badEffAngleFriction, badCohesion, badDryUnitWeight, 
   badSatUnitWeight, badPiezGeometry, badWatUnitWeight \\
   
   strat & - & coords & - \\
   stratX & - & [$\mathbb{R}$] & - \\
   stratY & - & [$\mathbb{R}$] & - \\
   phi & - & $\mathbb{R}$ & - \\
   coh & - & $\mathbb{R}$ & - \\
   gam & - & $\mathbb{R}$ & - \\
   gams & - & $\mathbb{R}$ & - \\
   piez & - & coords & - \\
   piezX & - & [$\mathbb{R}$] & - \\
   piezY & - & [$\mathbb{R}$] & - \\
   gamw & - & $\mathbb{R}$ & - \\
   xExt & - & [$\mathbb{R}$]\textsuperscript{1,2} & - \\
   xEtr & - & [$\mathbb{R}$]\textsuperscript{1,2} & - \\
   yLim & - & [$\mathbb{R}$]\textsuperscript{1,2} & - \\
   ltor & - & $\mathbb{B}$ & - \\
   ftype & - & $\mathbb{B}$ & - \\
   evnslc & - & $\mathbb{B}$ & - \\
   cncvu & - & $\mathbb{B}$ & - \\
   obtu & - & $\mathbb{B}$ & - \\
   \hline

\end{tabular}
\end{center}

\wss{Is there any value to combining slopeX and slopeY into a list of
  coordinates?  The same question applies for piezX and piezY.  It depends on
  how they are used in the code, but I'm not sure how slopeX is used.  I
  couldn't find it used anywhere else in the specification.}

\bmac{The reason slopeX is not used anywhere else in the document is because I 
used equations from the SRS for the specs that use the inputs for brevity. 
Also, the strat access program is what you're describing. I also included 
slopeX and slopeY in case there were scenarios where it was more convenient to 
only deal with either x or y. I changed the name of slopeX and slopeY to stratX 
and stratY to make this more clear.}

\subsection{Semantics}

\subsubsection{State Variables}

\textit{slope} : tuple of (strat : coords, phi : $\mathbb{R}$, coh : 
$\mathbb{R}$, gam : $\mathbb{R}$, gams : $\mathbb{R}$) 
(Appendix~\ref{Tbl:LayerParam})\\
\textit{piez} : tuple of (piez : coords, gamw : $\mathbb{R}$) 
(Appendix~\ref{Tbl:PiezParam})\\
\textit{search} : tuple of (Xext, Xetr, Ylim : 
[$\mathbb{R}$]\textsuperscript{1,2}) (Appendix~\ref{Tbl:SearchParam})\\
\textit{soln} : tuple of (ltor, ftype, evnslc, cncvu, obtu : 
$\mathbb{B}$) (Appendix~\ref{Tbl:SolnParam})\\

\subsubsection{Environment Variables}

\textit{in\_file} : String
\begin{itemize}
	\item \textit{in\_file} represents a file stored in the file system of the 
	hardware running \progname{}. \\
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
	\item load\_params is called before any of the other access programs.
\end{itemize}

\subsubsection{Access Routine Semantics}

load\_params(\textit{fname}):
\begin{itemize}
	\item transition:
	\begin{itemize}
		\item[] \textit{slope}, \textit{piez}, 
		\textit{search}, 
		\textit{soln} $\coloneqq$  $\textit{slope}^\prime$, 
		$\textit{piez}^\prime$, $\textit{search}^\prime$, 
		$\textit{soln}^\prime$\\ 
		where $\textit{slope}^\prime$, 
		$\textit{piez}^\prime$, $\textit{search}^\prime$, and 
		$\textit{soln}^\prime$
		are populated based on the contents of \textit{in\_file}.
	\end{itemize}

	\item exceptions:
	\begin{itemize}
		\item[] \textit{exc} $\coloneqq$ (\textit{fname} does not exist in file 
		system $\Rightarrow$ fileNotExist\\
		$|$ \textit{fname}[($|$\textit{fname}$|$ - 4)..($|$\textit{fname}$|$ - 
		1)] = ``.out'' $\Rightarrow$ badFileExtension\\
		$|$ \textit{in\_file} is not formatted correctly $\Rightarrow$ 
		unexpectedInput)
	\end{itemize}
\end{itemize}

\noindent verify\_params():
\begin{itemize}
	\item exceptions:
	\begin{itemize}
		\item[] \textit{exc} $\coloneqq$ ($\lnot (\forall(i : \mathbb{Z} | i 
		\in [0..|slope.strat|-2] : slope.strat[i].x - slope.strat[i+1].x \leq 
		0))$ $\Rightarrow$ badSlopeGeometry\\
		$|$ $\lnot (0 < slope.phi < 90)$ $\Rightarrow$ 
		badEffAngleFriction\\
		$|$ $\lnot (0 < slope.coh)$ $\Rightarrow$ 
		badCohesion\\
		$|$ $\lnot (0 < slope.gam)$ $\Rightarrow$ 
		badDryUnitWeight\\
		$|$ $\lnot (0 < slope.gams)$ $\Rightarrow$ 
		badSatUnitWeight\\
		$|$ $\lnot (\forall(i : \mathbb{Z} | i \in 
		[0..|piez.piez|-2] : piez.piez[i].x - piez.piez[i+1].x \leq 0))\\ 
		\lor piez.piez[0].x \neq slope.strat[0].x \\
		\lor piez.piez[|piez.piez|-1].x \neq slope.strat[|slope.strat|-1].x$\\ 
		$\Rightarrow$ badPiezGeometry\\
		$|$ ($\textit{slope.strat}[|\textit{slope.strat}|-1].x > 
		\textit{slope.strat}[0].x$ $\Rightarrow$ $\forall(i : \mathbb{Z} | i 
		\in [0..1] :\\
		\textit{search.Xext}[i] > 
		\textit{slope.strat}[|\textit{slope.strat}|-1].x \\
		\lor \textit{search.Xext}[i] < \textit{slope.strat}[0].x \\
		\lor \textit{search.Xetr}[i] >  
		\textit{slope.strat}[|\textit{slope.strat}|-1].x\\
		\lor \textit{search.Xetr}[i] < \textit{slope.strat}[0].x)$\\
		$|$ $\textit{slope.strat}[|\textit{slope.strat}|-1].x < 
		\textit{slope.strat}[0].x$ $\Rightarrow$ $\forall(i : \mathbb{Z} | i 
		\in [0..1] : \\
		\textit{search.Xext}[i] < 
		\textit{slope.strat}[|\textit{slope.strat}|-1].x \\
		\lor \textit{search.Xext}[i] > \textit{slope.strat}[0].x \\
		\lor \textit{search.Xetr}[i] < 
		\textit{slope.strat}[|\textit{slope.strat}|-1].x \\
		\lor \textit{search.Xetr}[i] > \textit{slope.strat}[0].x)$)\\ 
		$\Rightarrow$ badSlipGuess)\\
	\end{itemize}
\end{itemize}

\noindent strat():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.strat}\\
	\end{itemize}
\end{itemize}

\noindent stratX():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $slope.strat[0].x || 
		slope.strat[1].x ||$\\$ \dots || slope.strat[| 
		slope.strat|-1].x$\\
	\end{itemize}
\end{itemize}

\noindent stratY():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $slope.strat[0].y || 
		slope.strat[1].y ||$\\$ \dots || slope.strat[| 
		slope.strat|-1].y$\\
	\end{itemize}
\end{itemize}

\noindent phi():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.phi}\\
	\end{itemize}
\end{itemize}

\noindent coh():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.coh}\\
	\end{itemize}
\end{itemize}

\noindent gam():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.gam}\\
	\end{itemize}
\end{itemize}

\noindent gams():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.gams}\\
	\end{itemize}
\end{itemize}

\noindent piez():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{piez.piez}\\
	\end{itemize}
\end{itemize}

\noindent piezX():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $piez.piez[0].x || 
		piez.piez[1].x ||$\\$ \dots || piez.piez[| 
		piez.piez|-1].x$\\
	\end{itemize}
\end{itemize}

\noindent piezY():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $piez.piez[0].y || 
		piez.piez[1].y ||$\\$ \dots || piez.piez[| 
		piez.piez|-1].y$\\
	\end{itemize}
\end{itemize}

\noindent gamw():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{piez.gamw}\\
	\end{itemize}
\end{itemize}

\noindent xExt():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{search.Xext}\\
	\end{itemize}
\end{itemize}

\noindent xEtr():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{search.Xetr}\\
	\end{itemize}
\end{itemize}

\noindent yLim():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{search.Ylim}\\
	\end{itemize}
\end{itemize}

\noindent ltor():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.ltor}\\
	\end{itemize}
\end{itemize}

\noindent ftype():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.ftype}\\
	\end{itemize}
\end{itemize}

\noindent evnslc():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.evnslc}\\
	\end{itemize}
\end{itemize}

\noindent cncvu():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.cncvu}\\
	\end{itemize}
\end{itemize}

\noindent obtu():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.obtu}\\
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

\wss{I'm not suggesting we change the design, but I wonder if there is a
  different design that is more elegant?  I don't like that we are passing
  around so many parameters and lists.  At some point in the future, not as part
  of 741, I'd like to discuss a more OO style design.  What if we had an object
  for the soil mass and another for the slip surface?  The constructor could
  populate the necessary information and then the object could be queried for
  the services that matter.  The slip surface could be asked to return its own
  Fs, rather than use another module to calculate it.  This redesign probably
  won't go anywhere, but we should discuss it at some point.  We could just
  sketch out the access programs and state variables, to see if there is
  something viable.}

\bmac{We can discuss that, certainly}

% ---------------------------------------------------------------- %
% -------------------- GEN ALG MODULE ------------------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Genetic Algorithm Module} \label{sec:GenAlgMod}

\subsection{Module}
GenAlg

\subsection{Uses}

\subsubsection{Imported Access Programs}
Input (Section~\ref{sec:InputMod}), MorgPriceSolver (Section \ref{sec:MPMod}), 
Slicer (Section \ref{sec:SlicerMod}), KinAdm (Section \ref{sec:KinAdmMod}), 
SlipWeighter (Section \ref{sec:WeightMod}), Sequence 
(Section~\ref{sec:SequenceData}), Rand (Section~\ref{sec:Random})

\subsection{Syntax}

\subsubsection{Exported Constants}
MIN\_GENS = 100\\
NUM\_SLIPS = 20\\
REL\_DIFF = 0.00005\\
INIT\_NUM\_VERTICES = 4\\
NUM\_ADDS = 2\\

\subsubsection{Exported Data Types}
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{p{0.14\textwidth} c p{0.8\textwidth}}
	slip &=& tuple of (surf : coords, Fs : $\mathbb{R}$, G : coords, X : 
	coords, wt : $\mathbb{R}$) \\
	slips &=& [slip] \\
\end{longtable}

\wss{If you do introduce a module whose sole purpose is to export types, these
  types could go in that module.}

\bmac{As mentioned in an earlier comment, I will likely remove lots of the 
types I have defined. Types like slip, slips, coord, and coords, however, are 
used in many modules. Would it still make sense to write a separate module just 
for these types? The reason I hesitate is because in the actual 
implementation, none of these types exist. Slips are simply tuples and coords 
are arrays, though I found it easier to create types for these for the purposes 
of specification}

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		genetic\_alg & - & $\mathbb{R}$, coords, coords, coords & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
genetic\_alg():
\begin{itemize}
	\item output:
	\begin{itemize}
	\item[] \textit{out} $\coloneqq$ 
	weighter(\textit{slip\_surfs})[0].\textit{surf}, 
	weighter(\textit{slip\_surfs})[0].\textit{Fs}, 
	weighter(\textit{slip\_surfs})[0].\textit{G}, 
	and weighter(\textit{slip\_surfs})[0].\textit{X}, where 
	\textit{slip\_surfs}, of 
	type slips, is developed by:
	\begin{itemize}
		\item using rand to randomly generate coordinates for NUM\_SLIPS 
		potential slip surfaces, where the entry and exit x-coordinate for each 
		slip surface are computed according to \textit{generate\_slips(xEtr)} 
		and \textit{generate\_slips(xExt)}. Corresponding y-coordinates are 
		determined by interpolating on the slope geometry. The total number of 
		coordinates for each slip surface is INIT\_NUM\_VERTICES.
		\item using kinAdm to verify that the geometry of each potential slip 
		surface is physically realizable. If any are not, new slip surfaces are 
		randomly generated until NUM\_SLIPS valid slip surfaces have been 
		generated,
		\item using slicer to redefine each slip surface's coordinates based on 
		the desired number of slices
		\item using morg\_price to determine the \textit{Fs}, \textit{G}, and 
		\textit{X} fields of each slip 
		surface
		\item using weighter to determine the \textit{wt} field of each 
		slip surface
		\item using rand to generate a new pool of NUM\_SLIPS slip surfaces by 
		applying crossovers and mutations to the previous generation, with the 
		more lowly-weighted members having a greater likelihood of 
		contributing to the subsequent generations
		\item applying kinAdm, slicer, morg\_price, and weighter to the new 
		generation
		\item repeating the above two steps, but every time 
		$\frac{\text{MIN\_GENS}}{\text{NUM\_ADDS}+1}$ generations have occured, 
		vertices are added to the pool of slip surfaces halfway between each of 
		the existing vertices, so that the new slip surfaces each have 
		$(\text{INIT\_NUM\_VERTICES} * 2) - 1$ vertices. 
		\item repeating until at least MIN\_GENS have occured and the relative 
		difference between subsequent generations is less than REL\_DIFF.
	\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}
generate\_slips(\textit{Xrange}) : [$\mathbb{R}$] $\rightarrow$ $\mathbb{R}$\\
generate\_slips(\textit{Xrange}) = $(Xrange[0] + rand()*(Xrange[1] - 
Xrange[0]))$


% ---------------------------------------------------------------- %
% -------------------- KIN ADM MODULE ---------------------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Kinematic Admissibility
	Module} \label{sec:KinAdmMod}

\subsection{Module}
KinAdm

\subsection{Uses}
Input (Section~\ref{sec:InputMod}), Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		kinAdm & slip & $\mathbb{B}$ & - \\ \hline
		
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
\begin{itemize}
	\item The \textit{surf} field is populated for every member of the input 
	sequence of 
	slip data.
\end{itemize}

\subsubsection{Access Routine Semantics}
kinAdm(\textit{slip\_surf}):
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ ( $\lnot(\forall(i : \mathbb{Z} | i 
		\in [0..|\textit{slip\_surf}.\textit{surf}| - 2] : 
		\textit{slip\_surf}.\textit{surf}[i].x - 
		\textit{slip\_surf}.\textit{surf}[i+1].x \leq 0)) \\
		\lor \lnot is\_on\_slope(\textit{slip\_surf}.\textit{surf}[0])\\
		\lor \lnot 
		is\_on\_slope(\textit{slip\_surf}.\textit{surf}[|\textit{slip\_surf}.\textit{surf}-1|])\\
		\lor \lnot is\_in\_slope(\textit{slip\_surf}.\textit{surf})\\
		\lor (cncvu() \land 
		\lnot (is\_concave\_up(\textit{slip\_surf}.\textit{surf})))\\
		\lor (obtu() \land 
		\lnot (has\_no\_sharp\_angles(\textit{slip\_surf}.\textit{surf})))\\
		\Rightarrow false\\
		| true \Rightarrow true$)
	\end{itemize}
\end{itemize}

\bmac{Not sure if I'm allowed to use "else" here but don't know how else to 
express the "else" case succinctly}

\wss{With the conditional rule, you would just replace your ``else'' with
  ``True.''  The H\&S syntax works by following the first rule where the
  condition evaluates to true.  A true at the end acts as a catch all.}

\bmac{Makes sense, thanks. Fixed}

\subsubsection{Local Functions}
linSlope(\textit{point1}, \textit{point2}) : coord $\times$ coord $\rightarrow$ 
$\mathbb{R}$\\
linSlope(\textit{point1}, \textit{point2}) = $\frac{point2.y - 
point1.y}{point2.x 
- point1.x}$\\

\noindent is\_on\_slope(\textit{point}) : coord $\rightarrow$ $\mathbb{B}$\\
is\_on\_slope(\textit{point}) = $(\exists(i : \mathbb{Z} | i \in 
[0..|slope.strat|-1] : point = slope.strat[i]))\\ \lor (\exists(i : \mathbb{Z} 
| i \in [0..|slope.strat|-2] : point.y = linSlope(slope.strat[i], 
slope.strat[i+1])*point.x + \frac{slope.strat[i].y}{linSlope(slope.strat[i], 
slope.strat[i+1])*slope.strat[i].x})) $\\

\noindent is\_in\_slope(\textit{surf}) : coords $\rightarrow$ $\mathbb{B}$\\
is\_in\_slope(\textit{surf}) = $(\forall(i : \mathbb{Z} | i \in 
[1..|\textit{surf}|-2] : (\forall(j : \mathbb{Z} | j \in 
[0..|slope.strat|-2] \land slope.strat[j].x \leq \textit{surf}[i].x < 
slope.strat[j+1].x : \textit{surf}[i].y < (slope.strat[j].y +  
(\textit{surf}[i].x - slope.strat[j].x)*linSlope(slope.strat[j], 
slope.strat[j+1]))))))$\\

\noindent is\_concave\_up(\textit{surf}) : coords $\rightarrow$ $\mathbb{B}$\\
is\_concave\_up(\textit{surf}) = $(\forall(i : \mathbb{Z} | i \in 
[0..|\textit{surf}|-3] : linSlope(\textit{surf}[i+1], \textit{surf}[i+2]) \geq 
linSlope(\textit{surf}[i], \textit{surf}[i+1]))$\\

\noindent distance(\textit{point1}, \textit{point2}) : coord $\times$ coord 
$\rightarrow$ $\mathbb{R}$\\
distance(\textit{point1}, \textit{point2}) = $\sqrt{(point1.x - point2.x)^2 + 
(point1.y - point2.y)^2}$\\

\noindent has\_no\_sharp\_angles(\textit{surf}) : coords $\rightarrow$ 
$\mathbb{B}$\\
has\_no\_sharp\_angles(\textit{surf}) = $(\forall(i : \mathbb{Z} | i \in 
[0..|\textit{surf}|-3] :\\ \arccos \frac{(distance(\textit{surf}[i], 
\textit{surf}[i+1]))^2 + (distance(\textit{surf}[i+1], \textit{surf}[i+2]))^2 - 
(distance(\textit{surf}[i],  
\textit{surf}[i+2]))^2}{2*distance(\textit{surf}[i], 
\textit{surf}[i+1])*distance(\textit{surf}[i+1], \textit{surf}[i+2])} \geq 
1.9199))$\\

% ---------------------------------------------------------------- %
% -------------------- SLIP WEIGHTING MODULE ------------------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Slip Weighting
	Module} \label{sec:WeightMod}

\subsection{Module}
SlipWeighter

\subsection{Uses}
Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		weighter & slips & slips & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
\begin{itemize}
	\item The \textit{Fs} field is populated for every member of the input 
	sequence of 
	slip data.
\end{itemize}

\subsubsection{Access Routine Semantics}
weighter(\textit{slip\_surfs}):
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $\textit{slip\_surfs}^\prime$ such 
		that 
		$\textit{slip\_surfs}^\prime = 
		\textit{assign\_weights}(\textit{sort\_Fs}({\textit{slip\_surfs}}))$
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}
sort\_Fs(\textit{unsorted}) : slips $\rightarrow$ slips
sort\_Fs(\textit{unsorted}) = \textit{sorted} such that\\
$\forall(a : \textit{slip} | a \in \textit{unsorted} : \exists(b : 
\textit{slip} | b \in \textit{sorted} : b = a \land \textit{count}(a, A) = 
\textit{count}(b, B))) \land \forall(i : \mathbb{Z} | i \in [0..|unsorted|-1] : 
sorted[i].Fs \leq sorted[i+1].Fs)$\\

\noindent count(\textit{a}, \textit{A}) : slip $\times$ slips $\rightarrow$ 
$\mathbb{Z}$\\
count(\textit{a}, \textit{A}) = $+(x : slip | x \in A \land x = a : 1)$\\

\noindent \#\textit{The weight assigned to a given slip is the difference 
between that slip's factor of safety and the largest factor of safety, divided 
by the sum of all of these differences and cumulatively added, so that the slip 
with the lowest factor of safety has the lowest weight and the slip with the 
highest factor of safety has a weight of 1.}\\
\noindent assign\_weights(\textit{s}) : slips $\rightarrow$ slips\\
assign\_weights(\textit{s}) = $s'$ such that\\
$s'[0].wt = \frac{s[0].Fs - s[|s|-1].Fs}{+(j : \mathbb{Z} | j \in [0..|s|-1] : 
s[j].Fs - s[|s|-1].Fs)}$ and \\
$\forall(i : \mathbb{Z} | i \in [1..|s|-1] : s'[i].wt = s'[i-1].wt + 
\frac{s[i].Fs - s[|s|-1].Fs}{+(j : \mathbb{Z} | j \in [0..|s|-1] : s[j].Fs - 
s[|s|-1].Fs)})$\\

\wss{Could you say in a comment what is happening with assign\_weights.  It is
  not obvious from reading the definition.  The equality at the top of the
  fraction looks like it evaluates to a Boolean, but then you are diving by an
  integer?  Even if the formula is correct, you should explain it, since
  whatever is going on, it is complicated.}

\bmac{The boolean divided by an integer was a typo. Fixed that, and also added 
a comment with some explanation.}

% ---------------------------------------------------------------- %
% -------------------- SLICER MODULE ----------------------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Slip Slicing Module} \label{sec:SlicerMod}

\subsection{Module}
Slicer

\subsection{Uses}
Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		slicer & coords, $\mathbb{Z}$ & coords & - \\ \hline
		
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumption}
\begin{itemize}
	\item The integer input to \textit{slicer} is greater than the size of the 
	slip input to \textit{slicer}.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \#\textit{Based on the value of evnslc, there are two potential 
slicing algorithms that could be used. If evnslc is true, the slip surface's 
largest segment will be sliced in half, and then the new largest segment will 
be sliced in half, and so on until the desired number of slices is reached. If 
evnslc is false, each slice will be divided into an equal number of 
subslices such that the resulting number of slices is as close as possible to 
the desired number without going over.}

~\newline \noindent slicer(\textit{slip\_surf}, \textit{num\_slices}):
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ ($\textit{soln.evnslc} \Rightarrow$ 
		$\textit{slip\_surf}^\prime$ obtained by repeatedly applying 
		\textit{slip\_surf}[large\_segment(\textit{slip\_surf})] $||$ 
		midpoint(\textit{slip\_surf}[large\_segment(\textit{slip\_surf})], 
		\textit{slip\_surf}[large\_segment(\textit{slip\_surf})+1])
		$||$ \textit{slip\_surf}[large\_segment(\textit{slip\_surf})+1] until 
		$|\textit{slip\_surf}^\prime| = \textit{num\_slices}$ \\
		$| \lnot \textit{soln.evnslc} \Rightarrow$ $\textit{slip\_surf}^\prime$ 
		such that 
		$\forall(i : \mathbb{Z} | i \in [0..|\textit{slip\_surf}|-2] : 
		\textit{slip\_surf}^\prime[i*\textit{round\_down}(\frac{\textit{num\_slices}}
		{|\textit{slip\_surf}|-1})..(i+1)*\textit{round\_down}(\frac{\textit{num\_slices}}
		{|\textit{slip\_surf}|-1})] = \\
		subslice(\textit{round\_down}(\frac{\textit{num\_slices}}
		{|\textit{slip\_surf}|-1}), \textit{slip\_surf}[i], 
		\textit{slip\_surf}[i+1]))$
	\end{itemize}
\end{itemize}

\wss{The specification of the slicer access program is confusing to me.  As
  mentioned previously for another complex spec, could you please say in words,
  in a comment, what is going on here?}

\bmac{Added a comment above.}

\subsubsection{Local Functions}
large\_segment(\textit{surf}) : coords $\rightarrow$ $\mathbb{Z}$\\
large\_segment(\textit{surf}) = \textit{index} such that\\
$\forall(i : \mathbb{Z} | i \in [0..|\textit{surf}|-2] : 
\textit{surf}[\textit{index}+1] - \textit{surf}[\textit{index}] \geq 
\textit{surf}[i+1] - \textit{surf}[i])$\\

\noindent midpoint(\textit{point1}, \textit{point2}) : coord $\times$ coord 
$\rightarrow$ coord\\
midpoint(\textit{point1}, \textit{point2}) = $< \frac{point1.x + point2.x}{2}, 
\frac{point1.y + point2.y}{2} >$\\

\noindent round\_down(\textit{num}) : $\mathbb{R}$ $\rightarrow$ $\mathbb{Z}$\\
round\_down(\textit{num}) = \textit{rounded\_num} such that\\
$\forall(i : \mathbb{Z} | i \leq \textit{num} < i + 1 : \textit{rounded\_num = 
i})$\\

\noindent subslice(\textit{n}, \textit{point1}, \textit{point2}) : $\mathbb{Z}$ 
$\times$ coord $\times$ coord $\rightarrow$ coords\\
subslice(\textit{n}, \textit{point1}, \textit{point2}) = \textit{subslices} 
such that\\
$\forall(i : \mathbb{Z} | i \in [0..n] : subslices[i].x = point1.x + 
\frac{i}{n}*(point2.x - point1.x) \land subslices[i].y = point1.y + 
\frac{i}{n}*(point2.y - point1.y))$\\

% ---------------------------------------------------------------- %
% -------------------- MORG PRICE MODULE ------------------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Morgenstern-Price Calculation Module} \label{sec:MPMod}

\subsection{Module}
MorgPriceSolver

\subsection{Uses}

Input (Section~\ref{sec:InputMod}), PropertyCalc (Section 
\ref{sec:PropSortMod}), Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
MAX\_DIFF = 0.000001\\
MAX\_ITER = 20\\
MIN\_FS = 0.5\\

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline

  morg\_price & slip & slip & - \\ \hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A
 
\subsubsection{Access Routine Semantics}
morg\_price(\textit{slip\_surf}):
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $\textit{slip\_surf}^\prime$ where 
		$\textit{slip\_surf}^\prime$.\textit{Fs}, 
		$\textit{slip\_surf}^\prime$.\textit{G}, and 
		$\textit{slip\_surf}^\prime$.\textit{X} satisfy the following system of 
		equations, taken from the SRS document. The equations are presented 
		with the symbols from the SRS document for readability, though the 
		symbols $F_\text{S}$, $G$, and $X$ correspond to 
		$\textit{slip\_surf}^\prime$.\textit{Fs}, 
		$\textit{slip\_surf}^\prime$.\textit{G}, and 
		$\textit{slip\_surf}^\prime$.\textit{X}, respectively.\\
		
		(\iref{SRS-IM_FS}): \( {F_\text{S}}= 
		\frac{\displaystyle\sum_{i=1}^{n-1} \left[ 
		{R_{i}}
			\;{\displaystyle\prod_{c=i}^{n-1} \Psi_{c}
			}\right] + {R_{n}} }{\displaystyle\sum_{i=1}^{n-1} \left[ {T_{i}}
			\;{\displaystyle\prod_{c=i}^{n-1} \Psi_{c}
			}\right] + {T_{n}} } \)\\
		
		(\iref{SRS-IM_Lambda}): \( {C_{\text{num},i}}= \) 
		\(  \left\{
		\renewcommand{\arraystretch}{2}
		\begin{tabular}{ p{6.5cm} r} 
		$ {{b}_{\text{1}}}\left[{{G}_{\text{1}} + {H}_{\text{1}}}
		\right]{\tan\left(\alpha_{\text{1}}\right) } $ &  $
		i={\text{1}} $ \\
		\noindent\parbox[c]{\hsize} {$ {{b}_{i}} \left[
			\left({{G}_{i} + {G}_{i-1}}\right) +
			\left({{H}_{i} + {H}_{i-1}}\right)
			\right]{\tan\left(\alpha_{i}\right)} \\ +
			{{h}_{i}}\left( 
			-{2}\;{U_{\text{t},i}}\;{\sin\left(\beta_{i}\right)}
			\;\right) $}
		&  $ 2\leq i \leq{n-1} $ \\ $
		{{b}_{n}}\left[{{G}_{n-1} +
			{H}_{n-1}}\right]{\tan\left(\alpha_{n-1}\right)
		} $ &  $ i=n $ \\
		\end{tabular} 
		\renewcommand{\arraystretch}{1}
		\right. \)
		~\newline~\newline
		\( {C_{\text{den},i}}= \)
		\(  \left\{
		\renewcommand{\arraystretch}{2}
		\begin{tabular}{ p{6.5cm} r} 
		$ {{b}_{\text{1}}}{{G}_{\text{1}}}{f_{\text{1}}} $ &  $
		i=\text{1} $ \\ $ {{b}_{i}}\;{\left({
				{f_{i}}{{G}_{i}} +
				{f_{i-1}}{{G}_{i-1}} }\right)} $ &  $
		2\leq i \leq{n-1} $ \\ $
		{{b}_{n}}{{G}_{n-1}}{f_{n-1}} $ &  $
		i=n $ \\
		\end{tabular} 
		\renewcommand{\arraystretch}{1}
		\right. \) 
		~\newline
		\( \lambda= \frac{ \displaystyle\sum_{i=1}^{n} {C_{\text{num},i}}}
		{\displaystyle\sum_{i=1}^{n} {C_{\text{den},i}}} \) \\
		
		(\iref{SRS-IM_E}): \( G_{i}= \) 
		\(  \left\{
		\renewcommand{\arraystretch}{1.75}
		\begin{tabular}{ p{3cm} l} 
		$ \frac{ \left(F_\text{S}\right) T_{\text{1}} - R_{\text{1}} }{
			\Phi_{i} } $ &  $i=1$ \\
		\noindent\parbox[c]{\hsize} {$ \frac{ \Psi_{i-1} \cdot
				G_{i-1} + \left(F_\text{S}\right) \cdot T_{i} -
				R_{i} }{ \Phi_{i} } $} & 
		$2\leq i \leq n-1$ \\
		\noindent\parbox[c]{\hsize} {$0 $} &  $i=0$ $\lor$ $i=n$
		\end{tabular}
		\renewcommand{\arraystretch}{1}
		\right. \) \\
		
		(\dref{SRS-GD_X}): \( X = \lambda \cdot f \cdot G \) \\
		
		The solution method is to start with initial guesses $F_\text{S} = 1$ 
		and $\lambda = 0$ and use them to compute $F_\text{S}$ using 
		\iref{SRS-IM_FS} and $G$ using \iref{SRS-IM_E}, then use these values 
		to compute a new guess for $\lambda$ using \iref{SRS-IM_Lambda}. This 
		iteration continues until the absolute difference between $F_\text{S}$ 
		in the current iteration and in the previous iteration is less than 
		MAX\_DIFF, or until the absolute difference between $\lambda$ in the 
		current iteration and in the previous iteration is less than MAX\_DIFF. 
		When this occurs, $X$ is computed using \dref{SRS-GD_X}, and 
		$\textit{slip\_surf}^\prime.Fs, \textit{slip\_surf}^\prime.G, 
		\textit{slip\_surf}^\prime.X \coloneqq F_\text{S}, G, X$.
		If MAX\_ITER iterations occur, the solution is considered to be 
		non-converging. If the solution converges but $F_\text{S} <$ 
		MIN\_FS, the solution is considered to be spurious. In either case, 
		$\textit{slip\_surf}^\prime.Fs, \textit{slip\_surf}^\prime.G, 
		\textit{slip\_surf}^\prime.X \coloneqq 1000, [], []$.
	\end{itemize}
\end{itemize}

\wss{Nice to see excerpts from the SRS.  That is an encouraging sign.  The mix
  of equations and description seems like a good spec to me.}

\subsubsection{Local Functions}
N/A

% ---------------------------------------------------------------- %
% -------------------- PROPERTY SORTER MODULE -------------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Slice Property Calculation Module} \label{sec:PropSortMod}

\subsection{Module} 
PropertyCalc

\subsection{Uses}
Input (Section~\ref{sec:InputMod}), Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline

  prop\_calc & slip & - & - \\ 
  ub & - & [$\mathbb{R}$] & - \\
  ut & - & [$\mathbb{R}$] & - \\
  w & - & [$\mathbb{R}$] & - \\
  h & - & [$\mathbb{R}$] & - \\
  alpha & - & [$\mathbb{R}$] & - \\
  beta & - & [$\mathbb{R}$] & - \\
  hts & - & [$\mathbb{R}$] & - \\ \hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\textit{force} : tuple of (Ub, Ut, W, H : [$\mathbb{R}$]) 
(Appendix~\ref{Tbl:ForceParam})\\
\textit{angles} : tuple of (alpha, beta : [$\mathbb{R}$]) 
(Appendix~\ref{Tbl:AngleParam})\\
\textit{heights} : [$\mathbb{R}$]\\

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
\begin{itemize}
	\item prop\_calc is called before any of the other access programs.
\end{itemize}

\subsubsection{Access Routine Semantics}
prop\_calc(\textit{slip\_surf}):
\begin{itemize}
	\item transition:
	\begin{itemize}
		\item[] The equations used below contain symbols from the SRS 
		document for this project for the sake of brevity. The SRS should be 
		consulted for the definitions of these symbols.\\
		\item[] $\textit{force}, \textit{angles},	\textit{heights} \coloneqq 
		\textit{force}^\prime, \textit{angles}^\prime, \textit{soil}^\prime, 
		\textit{heights}^\prime$,\\
		~\newline
		where \\
		$\forall(i : \mathbb{Z} | i \in [1..|\textit{slip\_surf}|-1] :\\ 
		\textit{force}.Ub[i] = 0.5({U_{\text{b,}i,1}} + {U_{\text{b,}i,2}})\\
		\land \textit{force}.Ut[i] = 0.5({U_{\text{t,}i,1}} + 
		{U_{\text{t,}i,2}})\\
		\land \textit{force}.W[i] = 0.5(W_{i,1}+W_{i,2})\\
		\land \textit{force}.H[i] = \begin{cases}
			\frac{\left[{y_{\text{slope,}i}}-{y_{\text{slip,}i}}\right]^{2}}{2}{\gamma{}_\text{w}}+
			\left[{y_{\text{wt,}i}}-{y_{\text{slope,}i}}\right]^{2}{\gamma{}_\text{w}}
			& {y_{\text{wt,}i}}\geq{}{y_{\text{slope,}i}}\\
			\frac{\left[{y_{\text{wt,}i}}-{y_{\text{slip,}i}}\right]^{2}}{2}{\gamma{}_\text{w}}
			& 
			{y_{\text{slope,}i}}>{y_{\text{wt,}i}}>{y_{\text{slip,}i}}\\
			0 & {y_{\text{wt,}i}}\leq{}{y_{\text{slip,}i}}
			\end{cases}\\
		\land \textit{angles}.\textit{alpha}[i] =
			\arctan \left( \frac{y_{\text{slip,}i} -
			y_{\text{slip,}i-1}}{x_{\text{slip,}i} - x_{\text{slip,}i-1}} 
			\right) \\
		\land \textit{angles}.\textit{beta}[i] = \arctan \left( 
			\frac{y_{\text{slope,}i} -
			y_{\text{slope,}i-1}}{x_{\text{slope,}i} - 
			x_{\text{slope,}i-1}} 
			\right)\\
		\land \textit{heights}[i] = 
			0.5*(({y_{\text{slope,}i}}-{y_{\text{slip,}i}}) + 
			({y_{\text{slope,}i-1}}-{y_{\text{slip,}i-1}})))$,\\
			~\newline
			where \\
			${U_{\text{b,}i,1}}$ = ${\ell{}_{\text{b,}i}}\begin{cases}
			\left({y_{\text{wt,}i}}-{y_{\text{slip,}i}}\right){\gamma{}_{\text{w}}}
			 & 
			{y_{\text{wt,}i}}>{y_{\text{slip,}i}}\\
			0 & {y_{\text{wt,}i}}\leq{}{y_{\text{slip,}i}}
			\end{cases}$,\\
			~\newline~\newline
			${U_{\text{b,}i,2}}$ = ${\ell{}_{\text{b,}i}}\begin{cases}
			\left({y_{\text{wt,}i-1}}-{y_{\text{slip,}i-1}}\right){\gamma{}_{\text{w}}}
			 & 
			{y_{\text{wt,}i-1}}>{y_{\text{slip,}i-1}}\\
			0 & {y_{\text{wt,}i-1}}\leq{}{y_{\text{slip,}i-1}}
			\end{cases}$,\\
			~\newline~\newline
			${U_{\text{t,}i,1}}$ = ${\ell{}_{\text{s,}i}}\begin{cases}
			\left({y_{\text{wt,}i}}-{y_{\text{slope,}i}}\right){\gamma{}_{\text{w}}}
			 & 
			{y_{\text{wt,}i}}>{y_{\text{slope,}i}}\\
			0 & {y_{\text{wt,}i}}\leq{}{y_{\text{slope,}i}}
			\end{cases}$,\\
			~\newline~\newline
			${U_{\text{t,}i,2}}$ = ${\ell{}_{\text{s,}i}}\begin{cases}
			\left({y_{\text{wt,}i-1}}-{y_{\text{slope,}i-1}}\right){\gamma{}_{\text{w}}}
			 & 
			{y_{\text{wt,}i-1}}>{y_{\text{slope,}i-1}}\\
			0 & {y_{\text{wt,}i-1}}\leq{}{y_{\text{slope,}i-1}}
			\end{cases}$,\\
			~\newline~\newline
			$W_{i,1}$ = $b_{i}\begin{cases}
			\left({y_{\text{slope,}i}}-{y_{\text{slip,}i}}\right){\gamma{}_{\text{Sat}}}
			 & 
			{y_{\text{wt,}i}}\geq{}{y_{\text{slope,}i}}\\
			\left({y_{\text{slope,}i}}-{y_{\text{wt,}i}}\right)\gamma{}+\left({y_{\text{wt,}i}}
			-{y_{\text{slip,}i}}\right){\gamma{}_{\text{Sat}}}
			& {y_{\text{slope,}i}}>{y_{\text{wt,}i}}>{y_{\text{slip,}i}}\\
			\left({y_{\text{slope,}i}}-{y_{\text{slip,}i}}\right)\gamma{} & 
			{y_{\text{wt,}i}}\leq{}{y_{\text{slip,}i}}
			\end{cases}$,\\
			~\newline~\newline
			$W_{i,2}$ = $b_{i}\begin{cases}
			\left({y_{\text{slope,}i-1}}-{y_{\text{slip,}i-1}}\right){\gamma{}_{\text{Sat}}}
			& 
			{y_{\text{wt,}i-1}}\geq{}{y_{\text{slope,}i-1}}\\
			\left(\begin{array}{l}\left({y_{\text{slope,}i-1}}-{y_{\text{wt,}i-1}}\right)\gamma{}\\
			+\left({y_{\text{wt,}i-1}}
			-{y_{\text{slip,}i-1}}\right){\gamma{}_{\text{Sat}}} \end{array} 
			\right)
			& {y_{\text{slope,}i-1}}>{y_{\text{wt,}i-1}}>{y_{\text{slip,}i-1}}\\
			\left({y_{\text{slope,}i-1}}-{y_{\text{slip,}i-1}}\right)\gamma{} & 
			{y_{\text{wt,}i-1}}\leq{}{y_{\text{slip,}i-1}}
			\end{cases}$
			~\newline~\newline
	\end{itemize}
\end{itemize}

\noindent ub():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{force.Ub}\\
	\end{itemize}
\end{itemize}

\noindent ut():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{force.Ut}\\
	\end{itemize}
\end{itemize}

\noindent w():
\begin{itemize}
\item output:
\begin{itemize}
	\item[] \textit{out} $\coloneqq$ \textit{force.W}\\
\end{itemize}
\end{itemize}

\noindent h():
\begin{itemize}
\item output:
\begin{itemize}
	\item[] \textit{out} $\coloneqq$ \textit{force.H}\\
\end{itemize}
\end{itemize}

\noindent alpha():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{angles.alpha}\\
	\end{itemize}
\end{itemize}

\noindent beta():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{angles.beta}\\
	\end{itemize}
\end{itemize}

\noindent hts():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{heights}\\
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}
N/A

% ---------------------------------------------------------------- %
% -------------------- OUTPUT MODULE ----------------------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Output Module} \label{sec:OutputMod}

\subsection{Module}
Output

\subsection{Uses}

Sequence (Section~\ref{sec:SequenceData}), Plot (Section~\ref{sec:Plotting})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.35\textwidth}  p{0.15\textwidth} 
			p{0.25\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		verify\_output & $\mathbb{R}$ & - & negativeFS \\
		output & $\mathbb{R}$, coords, coords, coords, string & - & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}

\textit{out\_file} : String
\begin{itemize}
	\item \textit{out\_file} represents a file stored in the file system of the 
	hardware running \progname{}. \\
\end{itemize}

\noindent \textit{screen} : [$\mathbb{Z}$]
\begin{itemize}
	\item \textit{screen} represents the colour values for each pixel on the 
	screen of the hardware running \progname{}. \\
\end{itemize}

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
verify\_output(\textit{Fs}):
\begin{itemize}
	\item exceptions:
	\begin{itemize}
		\item[] \textit{exc} $\coloneqq$ $\textit{Fs} < 0$ 
		$\Rightarrow$ negativeFS\\
	\end{itemize}
\end{itemize}

\noindent output(\textit{Fs}, \textit{crit\_slip}, \textit{G}, \textit{X}, 
\textit{fname}):
\begin{itemize}
	\item transition:
	\begin{itemize}
		\item[] \textit{out\_file} is created at path $\textit{fname}$ $||$ 
		``.out''. The outputs of xEtr(), xExt(), yLim(), ftype(), \textit{Fs}, 
		\textit{crit\_slip}, \textit{G}, and \textit{X} are written to 
		\textit{out\_file}.
		\textit{screen} is modified to display the outputs of 
		plot(\textit{crit\_slip.x}, \textit{crit\_slip.y}), plot(\textit{G.x}, 
		\textit{G.y}), and plot(\textit{X.x}, \textit{X.y}).  \\
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}
N/A

% ---------------------------------------------------------------- %
% ---------------- SEQUENCE DATA STRUCTURE MODULE ---------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Sequence Data Structure Module} \label{sec:SequenceData}

\wss{Nice that you included the specification of this module.  You could have
  simply said, ``as implemented by Matlab,'' but I like this. Matlab has other
  operations on sequences that aren't specified (like assignment), but we
  shouldn't invest too much time in this spec, so you don't need to add this.}

\subsection{Module}
Sequence

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}

[T] = sequence of T, where T is any type

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		[\_] & Any number of values of type T & [T] & - \\ 
		\_(\_) & [T], $\mathbb{Z}$ & T & \\
		\_(\_:\_) & [T], $\mathbb{Z}$, $\mathbb{Z}$ & [T] & - \\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

N/A

\subsubsection{Access Routine Semantics}

[\_](Any number of values):
\begin{itemize}
	\item output: 
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ A sequence containing the arguments 
		passed to the function.
	\end{itemize}
\end{itemize}

\noindent \_(\_)(\textit{list}, \textit{int}):
\begin{itemize}
	\item output: 
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $list$[\textit{int}]	
	\end{itemize}
\end{itemize}

\noindent \_(\_:\_)(\textit{list}, \textit{int1}, \textit{int2}):
\begin{itemize}
	\item output: 
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $list$[\textit{int1}..\textit{int2}]
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

\subsubsection{Considerations}
This module is the sequence data type and operations on sequences implemented 
by Matlab.

% ---------------------------------------------------------------- %
% ---------------- RANDOM NUMBER GENERATION MODULE --------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Random Number Generation Module} \label{sec:Random}

\subsection{Module}
Rand

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		rand & - & $\mathbb{R}$ & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

N/A

\subsubsection{Access Routine Semantics}

rand():
\begin{itemize}
	\item output: 
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ A random number in the interval (0,1).
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

\subsubsection{Considerations}
This module is the rand function implemented by Matlab.

% ---------------------------------------------------------------- %
% ------------------------- PLOTTING MODULE ---------------------- %
% ---------------------------------------------------------------- %
\newpage
\section{MIS of the Plotting Module} \label{sec:Plotting}

\subsection{Module}
Plot

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		plot & [$\mathbb{R}$], [$\mathbb{R}$] & - & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

\textit{screen} : [$\mathbb{Z}$]
\begin{itemize}
	\item \textit{screen} represents the colour values for each pixel on the 
	screen of the hardware running \progname{}. \\
\end{itemize}

\subsubsection{Assumptions}

N/A

\subsubsection{Access Routine Semantics}

plot(\textit{x}, \textit{y}):
\begin{itemize}
	\item transition: 
	\begin{itemize}
		\item[] Modifies \textit{screen} to display a plot with $x$ on the 
		horizontal axis and $y$ on the vertical axis.
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

\subsubsection{Considerations}
This module is the plot function implemented by Matlab.

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

% ---------------------------------------------------------------- %
% ------------------------  APPENDIX --------------------------%
% ---------------------------------------------------------------- %
\section{Appendix}

\subsection{Parameter Tables} \label{sec:ParamTables}

\subsubsection{Layer Parameters} \label{Tbl:LayerParam}
\noindent
The elements of the structure which describes the mass of soil on 
which slope stability analysis is to be performed are explained in the table 
below.

\begin{center}
\begin{longtable}{ p{0.25\textwidth}
    p{0.75\textwidth}}\hline

  \textbf{Parameter} & \textbf{Description}\\ \hline

  \textit{strat} : coords
  & Coordinates describing the vertices of the slope of soil.\\

  \textit{phi} : $\mathbb{R}$ & The
  effective angle of friction of the soil.\\

  \textit{coh} : $\mathbb{R}$ & The
  effective cohesion of the soil.\\

  \textit{gam} : $\mathbb{R}$ & The dry
  unit weight of the soil.\\

  \textit{gams} : $\mathbb{R}$ & The
  saturated unit weight of the soil. \\ \hline
\end{longtable}
\end{center}

\subsubsection{Piezometric Parameter} \label{Tbl:PiezParam}
\noindent
The elements in the structure which describes the water table are 
explained in the table below.

\begin{center}
\begin{longtable}{ p{0.2\textwidth}
    p{0.8\textwidth}}\hline 
  \textbf{Parameter} & \textbf{Description}\\ \hline

  \textit{piez} : $coords$ & Coordinates describing the vertices of the water 
  table. If there is no water table than \textit{piez} is an empty array. \\

  \textit{gamw} : $\mathbb{R}$ & The unit weight of water. \\ \hline
\end{longtable}
\end{center}

\subsubsection{Search Range Parameters} \label{Tbl:SearchParam}
\noindent
The elements in the structure which holds parameters relating to 
the range of coordinates between which the critical slip surface may exist are 
described in the table below.

\begin{center}
\begin{tabular}{ p{0.2\textwidth}
    p{0.8\textwidth}}\hline 

  \textbf{Parameter} &
  \textbf{Description}\\ \hline

  Xext : $[\mathbb{R}]^{1,2}$ & The range of $x$-ordinates between which the 
  exit point of the critical slip surface may exist. Exit refers
  to the point of the slip at lower elevation toward which the mass of soil will
  move during failure. \\

  Xetr : $[\mathbb{R}]^{1,2}$ & The range of $x$-ordinates between which the
  entry point of the critical slip surface may exist. Entry
  refers to the point of the slip at higher elevation away from which the
  mass of soil will move during failure. \\

  Ylim : $[\mathbb{R}]^{1,2}$ & The range of $y$-ordinates between which
  the critical slip surface may exist. The larger value should be
  greater than the max $y$-ordinate of the slope. The smaller
  value is the lowest elevation to which the critical slip surface may 
  descend.\\ \hline
\end{tabular}
\end{center}

\subsubsection{Solution Parameters} \label{Tbl:SolnParam}
\noindent
The elements in the structure which holds parameters relating to the 
solution method are described in the table below.

\begin{center}
\begin{longtable}{ p{0.15\textwidth} 
    p{0.85\textwidth}}\hline 

  \textbf{Parameter} & \textbf{Description}\\ \hline

  ltor : $\mathbb{B}$ & Direction the slope is expected to
  experience failure in. If true then the side of the slope with a
  greater x-ordinate value is at a lower elevation. If false then the
  side of the slope with a greater x-ordinate is at a higher
  elevation.\\

  ftype : $\mathbb{B}$ & Function to use for interslice normal/shear force 
  ratio variation function. If true then the function is a constant (Spencer's 
  method). If false then the function is a half-sine (standard 
  Morgenstern-Price method). \\

  evnslc : $\mathbb{B}$ & Method for slicing a slip surface prior to analysis. 
  If true then slice slip surface into equal x-ordinate widths. If false then 
  slice distance between vertices into even number of slices. \\

  cncvu : $\mathbb{B}$ & Concave slip surface admissibility
  criterion. If true then an admissible slip surface must be concave
  upwards towards the surface. If false then an admissible slip
  surface does not need to pass this criterion.\\

  obtu : $\mathbb{B}$ & Angle slip surface
  admissibility criterion. If true then an admissible slip surface
  must have all interior angles greater than a set limit. If false
  then an admissible slip surface does not need to pass this
  criterion.\\ \hline
\end{longtable}
\end{center}

\subsubsection{Internal Force Parameters} \label{Tbl:ForceParam}
\noindent
The elements in the structure which holds parameters 
relating to the forces acting on a slice, and water in the slope acting
on itself, are described in the table below. $n$ refers to the number of slices 
composing the slip surface under evaluation, and is defined by the Slicer 
module (section \ref{sec:SlicerMod}).

\begin{center}
\begin{longtable}{ p{0.2\textwidth} 
    p{0.8\textwidth}}\hline 

  \textbf{Parameter} & \textbf{Description}\\ \hline

  Ub : $[\mathbb{R}]^{1,n}$ & Sequence of the force acting on the
  basal surface of a slice as a result of pore water pressure within
  the slice. From DD\ref{SRS-DD_Ub} of the SRS.\\
  
  Ut : $[\mathbb{R}]^{1,n}$ & Sequence of the force acting on the
  upper surface of a slice as a result of pore water pressure from standing
  water on the surface. From DD\ref{SRS-DD_Ut} of the SRS.\\

  W : $[\mathbb{R}]^{1,n}$ & Sequence of the downward force acting on
  the slice caused by the mass of the slice and the force of
  gravity. From DD\ref{SRS-DD_W} of the SRS.\\

  H : $[\mathbb{R}]^{1,n-1}$ & Sequence of the force acting into the
  interslice surfaces as a result of pore water pressure within the
  adjacent slices. From DD\ref{SRS-DD_H} of the SRS.\\ \hline
\end{longtable}
\end{center}

\subsubsection{Angle Parameters} \label{Tbl:AngleParam}
\noindent
The elements in the structure which holds parameters relating to 
the angles of the slice surfaces are described in the table below. $n$ refers 
to the number of slices composing the slip surface under evaluation, and is 
defined by the Slicer module (section \ref{sec:SlicerMod}).

\begin{center}
\begin{longtable}{ p{0.3\textwidth}
    p{0.7\textwidth}}\hline 
  \textbf{Parameter} & \textbf{Description}\\ \hline

  alpha : $[\mathbb{R}]^{1,n}$ & Sequence of the angle that the basal
  surface of the slice makes with the horizontal. From 
  DD\ref{SRS-DD_Angles_alpha} of the SRS.\\

  beta : $[\mathbb{R}]^{1,n}$ & Sequence of the angle that the upper
  surface of the slice makes with the horizontal. From 
  DD\ref{SRS-DD_Angles_Beta} of the SRS.\\ \hline
\end{longtable}
\end{center}

\end{document}
